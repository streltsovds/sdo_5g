# HmGrid

Это модуль отображающий таблички. Основан на компоненте [Data Table](https://vuetifyjs.com/ru/components/data-tables) от [Vuetify.js](https://vuetifyjs.com/ru/). Функционал расширен чтобы отражать и расширять возможности старого грида основанного на [BVB Grid](https://github.com/zfdatagrid/grid/tree/master/library/Bvb).

## Использование

### Основные действия
1. Вставить компонент в разметку.
    ```html
    <hm-grid></hm-grid>
    ```
2. Если ссылка для получения данных отличается от текущей то передать её в `load-url`.
    ```html
    <hm-grid load-url="ссылка_для_получения_данных"></hm-grid>
    ```
3. Также важно передать `id` грида.
    ```html
    <hm-grid load-url="ссылка_для_получения_данных" id="идентификатор_грида"></hm-grid>
    ```

### Что происходит

Компонент сделает `GET`-запрос по ссылке и должен получить начальные данные. В дальнейшем при изменении сортировки или пагинации он шлёт `POST`-запросы по ссылке и должен в ответ получать отсортированные и/или соответствующие запросу данные.

При изменении ссылки динамически (через `Vuex`) компонент сделает запрос по ней и запишет её как ссылку для отсылки запросов пагинации и сортировки.


## Разработка

### Договоренности

Так как модуль большой и насыщен всякой логикой, то необходимо максимально подробно все расписывать:

* Выносить логику по обработке данных приходящих/уходящих на бэкенд в папку `./module/logic`.

* Все действия по взаимодействию с API бэкенда - в модуле Vuex.

* Стараться писать [jsDoc](http://usejsdoc.org/) на сложные функции, особенно которые касаются бизнес-логики.

* Выносить `магические значения` в константы:
  ```js
  // например, вместо 
  selectedSubMassAction() {
    return this.selected["sub_mass_actions"];
  }
  // нужно перед экспортом объявить константу с подходящим названием
  const SUB_MASS_ACTIONS_PROPERTY = "sub_mass_actions";
  // и дальше использовать её
  selectedSubMassAction() {
    return this.selected[SUB_MASS_ACTIONS_PROPERTY];
  }
  ```
  Соглашение по наименованию констант - `SNAKE_CASE`.

* Папка `./components` для компонентов грида. Структура плоская без вложенных папок. Соглашение по наименованию компонентов - обязательный префикс `HmGrid`. Наименование `PascalCase`. Таким образом, из любых компонентов можно быстро подключить другой компонент всего лишь написав:
  ```js
  import HmGridMyFancyComponent from "./HmGridMyFancyComponent";
  ```

* Используйте [ESLint](https://eslint.org/docs/user-guide/getting-started).

* Объявляйте все переменные через `const`. Если вдруг нужно изменить значение переменной в процессе выполнения, только в таком случае объявляйте её через `let`.

### Особенности

Похожая конструкция в компоненте:
```js
import { createNamespacedHelpers } from "vuex";
import * as getters from "../module/getters/names";
/* ... */
export default {
  /* ... */
  beforeCreate() {
    const namespace = this.$options.propsData.gridModuleName;
    const { mapState, mapGetters } = createNamespacedHelpers(namespace);
    this.$composeComputed(
      mapGetters([getters.FOO_BAR]),
      mapState({ foo: state => state.bar })
    );
  },
/* ... */
}
```
Нужно такое для того, чтобы при инициализации компонента (поэтому lifecycle-метод `beforeCreate`), нам нужно смаппить из модуля грида во Vuex нужные нам данные. Но, так как наименование модуля вычисляется динамически и заранее мы его знать не можем, то мы передаем это наименование в `props` компонентов и добавляем сам нужные поля в `computed` свойства нашего компонента на этапе когда нам уже доступны `props` через `this.$options.propsData`, но реально компонент ещё не создан (lifecycle-метод `beforeCreate`). А функция-хелпер `$composeComputed` вписанная в прототип `Vue` нам помогает осуществить это. В него мы передаем маппнутые объекты которые нам предоставляют такие хелперы от `Vuex` как `mapState`, `mapGetters`.

## Вёрстка значений строк

Ссылки-иконки на карточки: шаблон `cardlink.tpl`, хэлпер `CardLink.php`.

Карточка сотрудника: `\User_ListController::indexAction()`

Карточка должности: `\HM_Controller_Action::updatePositionName()`
